export const privateKeysContent = {
  description: "Приватні ключі є основою безпеки в технології блокчейн. Вони дозволяють користувачам доводити право власності та підписувати транзакції. Ця стаття пояснює, як генеруються приватні ключі та важливість випадковості у цьому процесі.",

  entropySources: {
    title: "Джерела ентропії та CSPRNG",
    description: `Забезпечення криптостійкого рівня ентропії є передумовою формування надійного приватного ключа; відповідно до рекомендацій **RFC 4086** та **NIST SP 800-90B**, джерело випадковості повинно мати властивості непередбачуваності та стійкості до реконструкції попередніх і майбутніх вихідних даних. У випадку веб-середовища доцільно комбінувати рухи вказівника, таймінгові мікророзбіжності та шум WebRTC як первинний ентропійний пул, який після пост-обробки (наприклад, через криптографічну хеш-функцію SHA-256) ініціалізує детермінований CSPRNG – так досягається як висока швидкість, так і строгі гарантії випадковості.`,

    links: [
      {
        href: "https://tools.ietf.org/html/rfc4086",
        text: "RFC 4086: Вимоги до випадковості для безпеки"
      },
      {
        href: "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-90B.pdf",
        text: "NIST SP 800-90B: Рекомендації щодо ентропії"
      }
    ]
  },
  privateKeyGeneration: {
    title: "Способи генерації приватних ключів",
    fromCsprng: {
      title: "Генерація за допомогою криптографічно стійкого ГПВЧ",
      description: `Найпоширенішим та найбезпечнішим способом генерації приватних ключів є використання криптографічно стійкого генератора псевдовипадкових чисел (КСГПВЧ). Сучасні операційні системи та браузери надають вбудовані КСГПВЧ, які використовують різні джерела ентропії системи для отримання високоякісних випадкових чисел.

При використанні КСГПВЧ, згенеровані випадкові байти можуть бути використані безпосередньо як приватний ключ (якщо вони знаходяться у відповідному діапазоні) або бути оброблені через криптографічну хеш-функцію для забезпечення правильного форматування та розподілу.

Більшість криптовалютних гаманців та бібліотек використовують цей підхід для генерації приватних ключів, оскільки він поєднує безпеку з зручністю.`
    },
    fromEntropy: {
      title: "Генерація з ентропії",
      description: `Інший підхід до генерації приватних ключів полягає в зборі ентропії безпосередньо з дій користувача або джерел навколишнього середовища та її перетворенні в приватний ключ. Цей метод забезпечує прозорість та контроль користувача над джерелом випадковості.

Нижче наведено приклад генерації приватного ключа та адреси за допомогою ентропії, зібраної з рухів вашої миші. Переміщуйте мишу в межах поля нижче, доки не буде зібрано достатньо ентропії, потім натисніть кнопку для генерації ключа.

Зібрані байти ентропії відображаються, дозволяючи вам бачити точний випадковий вхід, використаний для створення вашого ключа. Цей підхід гарантує, що ключ згенеровано з ентропії, на яку ви безпосередньо вплинули.`,
      generateKeyButton: "Згенерувати",
      generateKeyNotEnoughEntropy: "Недостатньо рухів мишею для ентропії, спробуйте ще раз.",
    },
    fromSeed: {
      title: "Генерація з мнемонічної фрази. BIP-39",
      description: `BIP-39 (Bitcoin Improvement Proposal 39) визначає механізм генерації мнемонічної фрази та подальше перетворення її на seed, який уже безпосередньо використовується для отримання приватних ключів. Його основні складові такі:`,

      mnemonicPhrase: {
        title: "1. Генерація мнемонічної фрази",
        description: `**Мнемонічна фраза**, згідно з BIP-39, складається з наперед визначеної кількості слів зі спеціального словника. Зазвичай використовується набір із **2048 слів**, наявний у відкритому доступі (для англійської, японської, корейської й інших мов). Довжина фрази буває **12, 15, 18, 21 або 24 слова**. Найпоширеніші формати — це 12 або 24 слова.

За допомогою **криптографічно захищеного генератора випадкових чисел (CSPRNG)** спочатку отримують початкову бітову послідовність **entropy** (наприклад, 128 або 256 біт). Далі обчислюється хеш \`SHA-256(entropy)\` із якого беруть тільки перші \`entropy/32\` біти (наприклад, для entropy довжиною 256 біт беруть 8 біт). Ці біти називаються **контрольною сумою**. Потім отриману контрольну суму додають (конкатенують) до вихідних випадкових бітів.

Після додавання контрольної суми загальна довжина бітів стає такою, що її зручно розбити на **групи по 11 біт**, що інтерпретуються як число від 0 до 2047 (тобто 2¹¹ = 2048 можливих значень). Це число є номером слова у відповідному словнику.

Завдяки такому механізму з одного боку отримуємо просту для читання й запису мнемоніку, а з іншого – маємо вбудовану перевірку правильності. Якщо користувач випадково переплутає одне зі слів або порядок слів, то контрольна сума не співпаде, і при перевірці мнемоніка розпізнається як некоректна.

Нижче наведено інтерактивний приклад, що демонструє процес генерації мнемоніки. Натисніть "Згенерувати", щоб створити нову мнемонічну фразу та побачити всі кроки.`,
        generateButtonText: "Згенерувати ентропію"
      },

      seedGeneration: {
        title: "2. Перетворення мнемонічної фрази на seed",
        description: `Після отримання послідовності слів (мнемоніки) виконується перехід до **512-бітного seed** за допомогою функції **PBKDF2-HMAC-SHA512**.

На вхід PBKDF2 передають:
- **мнемонічну фразу** (словосполучення)
- так звану **«сіль» (salt)**, якою є рядок "mnemonic" (за BIP-39)
- додаткове **парольне слово (passphrase)**, якщо користувач обирає його

Отриманий у результаті 512-бітний seed і є тим головним секретом, із якого виконується подальше (детерміноване) виведення приватних ключів.

Нижче наведено інтерактивний приклад, що показує, як мнемонічна фраза перетворюється на seed, а потім на приватний ключ. Введіть власну мнемоніку або натисніть "Випадково", щоб згенерувати її.`,
        randomButtonText: "Випадково",
      },

      advantages: {
        title: "Переваги та безпечність мнемонік",
        description: `- **Зручність запам'ятовування**: Запам'ятати або зберігати мнемонічний ряд зі слів значно простіше, ніж громіздку бітову послідовність.
- **Відновлюваність**: Зі збереженого набору слів користувач у будь-який момент може знову отримати свій seed і відновити доступ до всіх відповідних приватних ключів.
- **Додатковий рівень безпеки**: Додавання парольної фрази (passphrase) підвищує безпеку, оскільки робить зловмиснику складнішим завдання підібрати seed навіть за наявності базових 12 чи 24 слів.
- **Вбудована перевірка**: Мнемоніки містять вбудовану контрольну суму, яка виконує функцію перевірки коректності. Якщо користувач допустив помилку або замінив слово іншим, контрольна сума не співпаде і мнемоніка буде визначена як некоректна.`
      },

      mnemonicValidator: {
        title: "Валідатор мнемонік",
        description: `Цей інтерактивний інструмент дозволяє перевірити будь-яку BIP-39 мнемонічну фразу. Введіть мнемоніку або згенеруйте випадкову, і інструмент покаже всі проміжні значення в процесі перевірки.

Якщо мнемоніка некоректна (через неправильні слова, неправильну довжину або невідповідність контрольної суми), відповідні поля будуть виділені червоним.`,
        randomButton: "Випадково"
      },

      hdWallets: {
        title: "HD-генерація. BIP-32, BIP-44",
        description: `Після отримання seed з мнемонічної фрази, наступним важливим кроком є фактична генерація приватних ключів. Для цього зазвичай використовується протокол **ієрархічно детермінованих гаманців (HD-гаманців)**, описаний у [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki).

**BIP-32** (Hierarchical Deterministic Wallets) визначає стандарт для створення деревоподібної структури ключів з одного головного ключа. Ця технологія надає наступні переваги:

- **Детермінованість**: Усі ключі генеруються з одного основного ключа або seed.
- **Ієрархічна структура**: Можливість формування деревоподібної структури з батьківськими та дочірніми ключами.
- **Криптографічна безпека**: Незнання приватного ключа на вищому рівні не дозволяє обчислити приватні ключі на нижніх рівнях.
- **Підвищена приватність**: Можливість генерувати нову адресу для кожної транзакції.
- **Простота резервного копіювання**: Для відновлення всіх ключів достатньо зберегти лише один майстер-ключ або seed-фразу.

Технічні деталі HD-гаманців:

1. **Майстер-ключ**: Створюється з entropy або seed-фрази за допомогою функції HMAC-SHA512.
2. **Розширені ключі**: Кожен ключ у дереві складається з приватного ключа та ланцюгового коду (chain code).
3. **Шляхи ключів**: Використовується спеціальний формат запису шляху до ключа в ієрархії (наприклад, m/0/1/2).
4. **Закритий доступ**: Можливість створення публічних ключів дочірніх елементів без знання відповідних приватних ключів.

#### Стандартизація структури гаманців (BIP-44)

На основі BIP-32, [BIP-44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) встановлює чіткий стандарт структури HD-гаманців з п'ятирівневою ієрархією:

\`m / purpose' / coin_type' / account' / change / address_index\`

де:
- **purpose**: Фіксоване значення 44' (показує, що використовується BIP-44)
- **coin_type**: Тип криптовалюти (0' для Bitcoin, 60' для Ethereum, тощо)
- **account**: Індекс облікового запису (0', 1', 2'...) для логічного розділення коштів
- **change**: Зовнішній ланцюг (0) для звичайних адрес або внутрішній ланцюг (1) для адрес здачі
- **address_index**: Порядковий номер адреси (0, 1, 2...)

> **Примітка**: Апостроф (') позначає загартовані деривації (hardened derivation), що забезпечує додатковий рівень безпеки.

Така структуризація дозволяє гаманцям підтримувати різні криптовалюти, мати кілька облікових записів та генерувати унікальні адреси для кожної транзакції, значно підвищуючи приватність користувача при одночасному збереженні простоти використання.`
      },

      links: [
        {
          href: "https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki",
          text: "BIP-39: Мнемонічний код для генерації детермінованих ключів"
        },
        {
          href: "https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt",
          text: "BIP-39 англійський словник (2048 слів)"
        },
        {
          href: "https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki",
          text: "BIP-32: Ієрархічно детерміновані гаманці"
        },
        {
          href: "https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki",
          text: "BIP-44: Багатоакаунтна ієрархія для детермінованих гаманців"
        }
      ]
    }
  },
  privateToPublic: {
    title: "Від приватного до публічного ключа, адреси",
    description: `Публічний ключ (public key) — це відкритий ключ, який може бути вільно
розповсюджений серед інших учасників мережі. За допомогою нього будь-
хто може перевірити автентичність підпису, створеного приватним ключем,
не отримуючи жодної інформації про сам приватний ключ.

Публічний ключ
генерується з приватного за допомогою спеціального криптографічного алгоритму,
який базується на математичних операціях над точками еліптичної кривої. У спрощеному
вигляді генерація публічного ключа виглядає наступним чином:
1. На вхід подається приватний ключ — випадкове число розміром 256 біт.
2. На основі приватного ключа, використовуючи множення на базову точку
еліптичної кривої, генерується публічний ключ, що являє собою координати
певної точки на цій кривій.
3. Отриманий публічний ключ має довжину 512 біт (64 байти) та, як правило,
кодується в hex-представленні.

Перетворення публічного ключа в адресу акаунту. Публічний ключ є
досить довгим і незручним для практичного використання у повсякденній взаємодії
з блокчейном, тому для зручності використовується додатковий крок — з
публічного ключа генерується адреса акаунту. Наприклад, в Ethereum ця адреса
отримується шляхом наступного алгоритму:
1. На вхід подається публічний ключ акаунту (512 біт, 64 байти).
2. Обчислюється криптографічний хеш KECCAK-256 від цього ключа.
3. Від отриманого хеша (256 біт, 32 байти) відкидаються перші 12 байтів, і
останні 20 байтів стають адресою акаунту.
4. Отримана адреса (160-бітна, 20 байт) використовується як унікальний
ідентифікатор акаунту у мережі Ethereum.`,
    generatorPoint: {
      title: "Генераторна точка G у secp256k1",
      description: `Генераторна точка G — це фіксована точка на еліптичній кривій secp256k1, яка служить основою для всіх операцій з публічними ключами. Це заздалегідь визначена константа, яку спільно використовують усі, хто працює з кривою secp256k1.

Коли ми виконуємо множення точки еліптичної кривої для генерації публічного ключа, ми по суті обчислюємо формулу:

**Публічний ключ = Приватний ключ × G**

Ця операція передбачає додавання генераторної точки G до самої себе стільки разів, скільки вказано приватним ключем (використовуючи додавання точок еліптичної кривої). Завдяки математичним властивостям еліптичних кривих, навіть якщо G відома всім, обчислювально неможливо повернути процес і визначити приватний ключ з публічного ключа.

Точні координати генераторної точки G на кривій secp256k1:

\`\`\`
x: 79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
y: 483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8
\`\`\`

Нижче ви можете спробувати створити власну пару ключів, виконавши множення на еліптичній кривій. Введіть власний приватний ключ або згенеруйте випадковий, щоб побачити отриманий публічний ключ і адресу.`
    },
    links: [
      {
        href: "https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm",
        text: "Алгоритм цифрового підпису на еліптичних кривих (ECDSA)"
      },
      {
        href: "https://ethereum.org/uk/developers/docs/accounts/",
        text: "Пояснення облікових записів Ethereum"
      }
    ]
  },
};
